# SoftwareEngineeringLab-E2
# آزمایش دوم آز مهندسی نرم افزار
## محمدرضا یوسف پور 97106324
## سید مهدی فقیه 97106198
### درصد مشارکت هر دو اعضای تیم در فرایند این پروژه یکسان بوده است

در این پروژه ما سه شاخه ی merge-sort و selection-sort و math را ساختیم 
که در شاخه ی merge-sort تابع مرتب سازی به روش merge-sort را پیاده کردیم
در شاخه ی selection-sort هم تابع مرتب سازی به روش selection را پیاده کردیم.
در شاخه ی math هم یک سری توابع ابتدایی از ریاضیات را پیاده کردیم

شاخه ی main را محافظت کردیم به صورتی که تنها با pull request , review و پذیرش عضو دیگر گروه امکان مرج وجود داشته باشد.

در هنگام پذیرش pull request  موجود درشاخه ی merge-sort به کانفلیکت برنخوردیم اما در هنگام پذیرش شاخه ی selection-sort  به کانفلیکت برخوردیم و آن را resolve  کردیم.

بعد از فرایند بالا ابتدا main را math مرج کردیم تا راه عکس را هم امتحان کرده باشیم

# پرسش ها
1- پوشه .git به منظور نگهداری اطلاعات مربوط به پروژه بر روی گیت استفاده می شود که تغییرات stash شده، کامیت های ثبت شده، برنچ های local یا remote موجود و ... را شامل می شود.

2- منظوراز atomic بودن این است که یا کل یک فرایند انجام می شود یا هیچ بخشی از آن انجام نمی شود. در واقع atomic بودن کامیت به این معناست که اگر در فرایند push یا merge آن کانفلیکتی در تعدادی از تغییرات اعمال شده رخ دهد، بقیه تغییرات نیز push یا merge نخواهند شد. در مورد pull request نیز به شکل مشابه منظور این است که اگر کانفلیکتی رخ دهد هیچ بخشی از تغییرات برنج دیگر، pull نمی شود.

3- عملیات fetch تمام تغییرات مربوط به تمام برنچ ها را در لوکال ما دریافت می کند اما آنها را merge یا pull نمی کند و تغییری در فایل های لوکال ایجاد نمی کند. عملیات pull تمام تغییرات فعلی مربوط به برنچ فعلی را از remote دریافت کرده و فایل های لوکال را نیز آپدیت می کند. در واقع عملیات pull از یک fetch و یک merge تشکیل شده است. عملیات merge فایل های لوکال را با برنچ دیگر یا با تغییرات remote همین برنچ، آپدیت می کند. در عکس زیر این توضیحات مشخص شده است.

![download](https://user-images.githubusercontent.com/45327750/201314742-497abbda-5722-4e6d-8dfd-48892cdc5452.png)

4- دستور clone برای دریافت کل اطلاعات یک ریپازیتوری استفاده می شود که آنها را در لوکال خود داشته باشیم ولی rebase برای ترکیب یا جابه جایی تعدادی از کامیت های پشت سر هم کاربرد دارد بدین شکل که میتوان تعدادی کامیت را از یک برنچ به برنچی دیگر منتقل کرد. در عکس زیر کامیت C4 با استفاده از دستور rebase به پس از C3 منتقل شده است و چون تنها کامیت برنچ experiment بوده است پس این برنچ نیز به آنجا منتقل شده است.

![image](https://user-images.githubusercontent.com/45327750/201313388-9d253189-eabc-40e2-8d33-307521cd30e4.png)


5- دستور revert برای برگرداندن تغییرات یک کامیت انجام می شود و کل تغییرات کامیت را بر می گرداند و برای این کار نیز یک کامیت جدید اضافه می کند که اگر کامیت اصلی به اسم C1‎ باشد کامیت جدید به اسم Revert "C1" خواهد بود

دستور git reset  وظیفه ی این را دارد که تغییراتی را که ما در local  خود انجام داده ایم را ignore  می کند و به اصطلاحی  ما را به آخرین state ای که در git  داشتیم می برد.

![git-reset-vs-git-revert](https://user-images.githubusercontent.com/45511559/201316766-dd247467-3f92-4d05-9d49-41cdb0443eb7.jpg)

6- یک snapshot نمایشی از وضعیت فعلی فایل های ردیابی شده شما در قالب یک مانیفست است که می تواند با سایر مانیفست ها مقایسه شود تا تفاوت ها در کجا وجود دارد. Git فقط تفاوت‌های بین مانیفست‌ها را از اولین لحظه ردیابی می‌کند.‎

در  git  ما دارای سه حالت هستیم  حالت ها به ترتیب modified و stage و commited هستند. modified به این معنا است که ما فایل را تغییر داده ایم اما هنوز commit نکردیم حالت stage  به این معنا است که یک فایل modified شده را انتخاب کردیم که در کامیت بعدی وجود داشته باشد.
در واقع هنگام کامیت فایل های stage  شده محتوی یک کامیت را تشکیل می دهد.

